### MySQL 事务

#### 一、基本要素

MySQL事务主要用于处理操作量大、复杂度高的数据，比如需要删除一条数据时，其连带的外键表也要进行删除，这些数据库操作的语句构成一个事务。

##### 1、ACID

事务由一组SQL语句组成，是一个逻辑处理单元，具有4个特性或属性，通常称为事务的ACID属性

1. Atomicity 原子性：一个事务（Transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从没有执行过一样；
2. Consistency 一致性：在事务开始之前和结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，例如资料的精确度、串联性以及后续数据库可以自发地完成预定的工作；
3. Isolation 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）；
4. Durability 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失；

##### 2、并发事务的问题

1. 更新丢失（Lost Update）：事务A和事务B选择同一行，基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，当并发执行时可能会导致丢失更新；
2. 脏读（Dirty Reads）：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据就是脏数据；
3. 不可重复读（No-Repeatble Reads）：事务A多次读取一个数据，事务B在事务A多次读取的过程中对数据做了更新操作并提交，导致事务A读取同一个数据时，结果不一致。**该问题的侧重点在于同一个数据的不同结果**；
4. 幻读（Phantom Reads）：事务A多次读取了几行数据，事务B在事务A的多次读取过程中插入或删除一些数据，导致事务A读取时得到了不一样数量的结果集。**该问题的侧重点在于多次读取的数量不一致**；

更新丢失的问题通常是可以避免的，最好的方式是在应用程序层面解决，比如加锁。其他问题都是数据库读一致性的问题，必须由数据库提供一定的隔离机制来解决：

a）加锁，一个事务读取数据时对其加锁，阻塞其他事务对数据的修改；

b）多版本控制（Multiple Version Concurrency Control），简称MVCC或MCC，也称为多版本数据库：不用加任何锁，通过一定机制生成数据库请求时间点的一致性数据快照（Snapshot），并使用这个快找提供一定级别的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本。

#### 二、隔离级别

为了解决并发事务的问题，数据库拟定了几种隔离级别来解决。

1. READ-UNCOMMITED（读未提交）：最低的隔离级别，允许读尚未提交的数据变更，可能会导致脏读、幻读或不可重复读；
2. READ-COMMITED（读已提交）：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生；
3. REPEATABLE-READ（可重复读）：对同一字段的多次读取结果都是一致的，除非数据是本身事务自己所修改的，可以阻止脏读和不可重复读，幻读仍有可能发生；
4. SERIALIZABLE（可串行化）：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，事务之间完全不可能产生干扰，该级别可以防止上述所有问题发生；

执行以下命令，查看当前数据库的事务隔离级别：

``` mysql
SHOW VARIABLES LIKE 'tx_isolation'
```

这里通过一些事例来表述可能产生脏读、不可重复读和幻读的情况和事务隔离级别如何解决这些问题。

数据库的事务隔离级别越严格，并发副作用越小，但付出的代价越大，因为事务隔离级别实质上就是使事务在一定程度上『串行化』执行，这显然与『并发』是矛盾的。同事，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对『不可重复读』和『幻读』并不敏感，更关心数据并发访问的能力。

**Read Uncommited**

​	读未提交，指一个事务可以读取另一个未提交事务的数据。

​	事例：有一个存折表，记录了id为1的账户有0元。事务A读取该账户并增加100元，但并未提交。此时事务B读取该账户发现有100元，并打算做扣减操作。此时事务A主动回滚，将账户恢复为0元，导致事务B在执行扣减时失败。这就是 **脏读**。

**Read Commited**

​	读已提交，顾名思义，就是一个事务要等到另一个事务提交后才能读取到数据。

​	事例：有一个存折表，记录了id为1的账户有100元。事务A读取该账户，发现此时有100元，则即将对其扣减10元。此时事务B读取该账户，发现有100元，并立即扣减100元并提交。那么事务A在提交前又主动查询了一次账户余额，发现账户为0元，无法扣款，便抛出异常。

这个事例中出现一个事务范围内的2次查询，返回了不同的数据，这就是 **不可重复读**。

**Repeatable Read**

​	重复读，就是在开始读取数据（事务开始）时，不再允许修改操作。**MySQL的默认事务隔离级别就是 Repeatable Read**。

​	事例：有一个存折表，记录了id为1、2、3一共三个账户，每个账户分别有0，0，100元。事务A读取大于100元的账户，发现有1个账户（id为3）。此时事务B插入了一个账户，id为4，并标记其有100元。此时事务A提交时，输出了2个账户（id为3、4），导致前后查询的结果不一致，这就是 **幻读**。

**Serializable 串行化**

串行化是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读和幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较消耗数据库性能，一般不使用。

**比较**

| 事务隔离级别    | 读一致性                                 | 脏读 | 不可重复读 | 幻读 |
| --------------- | ---------------------------------------- | ---- | ---------- | ---- |
| Read-Uncommited | 最低级别，只能保证不读取物理上损坏的数据 | 是   | 是         | 是   |
| Read-Commited   | 语句级                                   | 否   | 是         | 是   |
| Repeatable-Read | 事务级                                   | 否   | 否         | 是   |
| Serializable    | 最高级别，事务级                         | 否   | 否         | 否   |

需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高，并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。

MySQL InnoDB存储引擎的默认隔离级别是 Repeatable-Read（可重复读），我们可以通过 `` SELECT @@tx_isolation `` 命令来查看。而在 MySQL 8.0 之后，这个命令改为 `` SELECT @@transaction_isolation ``。

这里需要注意的是：与SQL标准不同的地方在于 InnoDB存储引擎在 Repeatable-Read（可重复读）的隔离级别下使用的是 Next-Key Lock 算法，因此可以避免幻读的产生，这与其他数据库（如MSSQL）是不同的。所以说，InnoDB存储引擎默认的Repeatable-Read隔离级别也可以保证事务的隔离性要求，避免幻读，也保留了比较好的并发性能。

> Next-Key Lock 可参考《高性能MySQL》，或参考一些博客：《[Innodb锁机制：Next-Key Lock 浅谈](https://www.cnblogs.com/zhoujinyi/p/3435982.html)》、《[Next-Key Locks](!https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks)》、《[InnoDB Next-Key Lock 浅析](!https://zhuanlan.zhihu.com/p/35477890)》

#### 三、MVCC 多版本并发控制

MySQL的大多数事务型存储引擎的实现，都不是简单的行级锁。基于提高并发性的考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL等，只是实现的机制各不相同。可以认为，MVCC是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现的机制不同，但大都实现了非阻塞读，写操作也是锁定必要的行。

MVCC通过保存数据在某个时间点的快照来实现，分为**乐观并发控制（Optimistic）**和**悲观并发控制（Pressimistic）**。

InnoDB通过在每行记录后面保存2个隐藏列来实现，一列保存了行的创建时间，一列保存了行的过期时间，用系统版本号（System Version Number）来表示。每开始一个新的事务，系统版本号会自增，事务开始时刻的系统版本号，会作为事务的版本号，用来查询到每行记录的版本号进行比较。

下面以默认的事务隔离级别（RR）来描述MVCC如何工作：

1) **SELECT**：InnoDB会根据以下两个条件检查每行记录：

   a）只查找版本早于当前事务版本的数据行，保证事务读取到的行，要么是在开始事务之前存在的，要么是事务自身插入的；

   b）行的删除版本号，要么未定义，要么大于当前事务版本号，保证事务读取到的行，在事务开始之前未被删除；

2) **INSERT**：为新插入的每一行保存当前系统版本号作为行版本号；

3) **DELETE**：为删除的每一行保存系统版本号作为行删除标识；

4) **UPDATE**：为插入的一行新记录保存当前系统版本号版本号为行版本号，同时保存当前系统版本号到原来行 作为删除标识；

保存这两个额外系统版本号，使得大多数操作都不用加锁，数据操作简单，性能高，且能保证只会读取到符合要求的行。不足之处是每行记录都要额外的存储空间，需要做更多的行检查工作和维护工作。

> **MVCC只在 Read-Commited 和 Repeatable-Read 两种隔离级别下工作。**

#### 四、事务日志

​	InnoDB使用日志来减少提交事务时的开销，因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新（flush）到磁盘中。事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到此盘中，需要很多随机I/O。

​	InnoDB假设使用常规磁盘，随机I/O比顺序I/O昂贵，因为一个I/O请求需要磁盘寻道，然后等待磁盘上读出需要的部分，再转到开始位置。InnoDB用日志把随机I/O变成顺序I/O，一旦日志被安全的写入到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并恢复已经提交的事务。InnoDB有一个后台线程刷新这些变更到文件中，这个线程可以批量组合写入，使得数据写入更顺序。

​	事务日志可以帮助提高效率：

1. 使用事务日志，存储引擎在修改表数据时，只需要修改其内存拷贝，再把修改行为记录到硬盘上的事务日志中，而不用每次都修改数据本身；
2. 事务日志采用的是追加（Append）的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不是随机I/O，这提高了磁盘读写的效率；
3. 事务日志持久化以后，内存中被修改的数据，在后台可以慢慢的刷回磁盘；
4. 如果数据的修改一纪念碑谷记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分的修改；

目前来说，大多数存储引擎都是这样实现的，我们通常称之为**预写式日志（Write-Ahead Logging）**，修改数据需要写2次磁盘，一次写日志，一次写数据；

##### 1、事务的实现

事务的实现是基于数据库的存储引擎，不同的存储引擎对事务的支持程度不一样。MySQL中支持事务的存储引擎是InnoDB和NDB。

事务的实现，本质就是ACID特性的实现。

事务的隔离性（Isolation）是通过锁实现的，而事务的原子性（Atomicity）、一致性（Consistency）和持久性（Durability）是通过事务日志来实现。

##### 2、日志类型

事务的日志包括：**redo log** 和 **undo log**

**redo log**

​	实现原子性和持久性。

​	事务开始前，事务中的操作都会写入存储引擎的日志缓冲区 buffer，在事务提交之前，这些缓冲的日志都需要刷新（flush）到磁盘中持久化，这就是日志先行（预写式日志 Write-Ahead Logging）。

​	当事务提交之后，在 buffer pool 中映射的数据文件，才会慢慢耍新到磁盘，此时如果数据库崩溃或者宕机，系统重启时，存储引擎会根据 redo log 把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回复你，这是基于恢复策略而定的。

​	在系统启动时，已经为 redo log 分配了一块连续的存储空间，以顺序追加的方式记录 redo log，通过顺序I/O来改变性能。所有的事务共享 redo log 的存储空间，各自按照语句执行顺序交替记录在一起。

**undo log**

​	实现一致性。

​	在事务执行过程中，除了 redo log，还会记录一定量的 undo log。undo log 记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据 undo log 进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他事务做的操作。

​	undo log 记录的是部分完成并写入磁盘的 未完成事务，默认情况下，undo log 是记录在表空间中的（共享表空间或独享表空间）

两种日志记录均可以视为一种回复操作，redo log 是恢复提交事务修改的page操作，而 undo log 是回滚行记录到特定版本。二者记录的内容也不同，redo log 是屋里日志，记录页的屋里修改操作。undo log 是逻辑日志，根据每行记录进行记录。

除了上述两种日志外，MySQL还有以下几种日志类型：

1. 错误日志：记录出错信息，也记录一些警告信息或正确的信息；
2. 查询日志：记录所有对数据库请求的信息，不论这些请求是否得到正确的执行；
3. 慢查询日志（slow log）：设置一个阈值，将运行时间超过该值的所有SQL语句记录到慢查询日志中；
4. 二进制日志（bin log）：记录对数据库执行更改的所有操作；
5. 中继日志：也是二进制日志，用来恢复slave；
6. 事务日志：redo log 和 undo log；



##### 3、MySQL对分布式事务的支持

分布式事务的实现方式有很多，既可以采用InnoDB提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。

MySQL从5.0.3InnoDB存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动（Action），这些Action本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。

在MySQL中，使用分布式事务设计 **一个或多个资源管理器** 和 **一个事务管理器** 。

![img](https://pic1.zhimg.com/80/v2-9ff2debf307f7640a7bbe56383a4b970_720w.jpg)

如上图，展示了分布式事务模型，主要由3个组成部分：应用程序（Application Program，简称AP）、资源管理器（Resource Manager，简称RM） 和 事务管理器（Transaction Manager，简称TM）：

1. AP：定义了事务的边界，指定需要做哪些事务；
2. RM：提供了访问事务的方法，通常一个数据库就是一个资源管理器；
3. TM：协调参与了全局事务中的各个事务；

分布式事务采用两段式提交（two-phase commit）的方式：

1. 第一阶段所有的事务节点开始准备，告诉事务管理器ready。
2. 第二阶段事务管理器告诉每个节点是commit还是rollback。如果一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。

