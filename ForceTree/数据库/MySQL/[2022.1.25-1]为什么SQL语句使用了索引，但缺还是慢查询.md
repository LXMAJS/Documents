## 为什么SQL语句使用了索引，但缺还是慢查询

From：极客时间     By：林晓斌

常有同学问我，我的一个SQL使用了索引，但为什么还是被记录到慢查询中？我们就从这个问题开始今天的讨论。请看下面的表：

``` mysql
// 创建一个表t
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `a` int(11) DEFAULT NULL,
  `b` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `a` (`a`)
) ENGINE = InnoDB;

// 插入一些数据
INSERT INTO `t` VALUES (1, 1, 1), (2, 2, 2);
```

首先，MySQL 判断一个 SQL 是否是慢查询，依据的是 SQL 语句的执行时间，它会根据 SQL 语句的执行时间，与 ``long_query_time`` 这个系统参数做比较，如果大于 ``long_query_time``，则记录到慢查询日志中。这个参数的默认值是 10s，但我们通常会设置为1s，对于延时敏感的业务，甚至会小于1s。

而对于语句是否使用索引，意思是我们在使用 ``explain`` 来分析 SQL 语句时，有没有使用表的索引。如下：

``` mysql
mysql> explain select * from t;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | t     | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
1 row in set (0.01 sec)
///////////////////////////////////////////////
mysql> explain select * from t where id > 0;
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | t     | range | PRIMARY       | PRIMARY | 4       | NULL |    2 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
1 row in set (0.01 sec)
///////////////////////////////////////////////
mysql> explain select * from t where a > 0;
+----+-------------+-------+-------+---------------+------+---------+------+------+-----------------------+
| id | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra                 |
+----+-------------+-------+-------+---------------+------+---------+------+------+-----------------------+
|  1 | SIMPLE      | t     | range | a             | a    | 5       | NULL |    2 | Using index condition |
+----+-------------+-------+-------+---------------+------+---------+------+------+-----------------------+
1 row in set (0.00 sec)
```

从上面可以看到，第一个 SQL 的 key 是 **NULL**，表示没有使用索引；第二个 SQL 的 key 是 **PRIMARY**，表示使用了主键索引；第三个 SQL 的 key 是 **a**，表示使用了我们定义的 a 这个索引。

实际上第三个 SQL 扫描了整个索引树a，因为数据只有2行，所以索引树的扫描很快就结束了。如果数据量较大，如百万、千万级别的数据，第二个 SQL 还是可以执行很快，但第三个 SQL 就肯定很慢了。更极端的情况下，这个数据库所在的机器 CPU压力很高，那么第二个 SQL 的执行时间也很可能超过 long_query_time，被记录到慢查询日志里面。

所以，是否使用索引，只表示了 SQL 语句的执行过程，而是否记录慢查询是由语句的执行时间来决定的，可能会受各种外部因素的影响。也就是说，是否使用索引，和是否被记录到慢查询，没有必然的联系。

#### 何为 "使用了索引"

InnoDB是索引组织表，所有的数据都存储在索引树上，而主键索引存储了该表的所有数据。

![2022_1_25_1_1_2](Images/2022_1_25_1_1_2.jpg)

根据上面的示例，我们知道这个表有2个索引，一个主键索引，一个索引a。那么从逻辑上说，所有的查询都至少要用到了1个索引（即主键索引）。假设执行 ``select * from t where id > 0`` ，你觉得是否使用到了索引？

``` mysql
mysql> explain select * from t where id > 0;
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
|  1 | SIMPLE      | t     | range | PRIMARY       | PRIMARY | 4       | NULL |    2 | Using where |
+----+-------------+-------+-------+---------------+---------+---------+------+------+-------------+
1 row in set (0.00 sec)
```

我们可以看到，key 显示的是 **PRIMARY**，但索引优化器认为，需要根据主键索引定位到第一个满足 id > 0 的值，所以即使 key 不是 NULL，也可能进行全表扫描的。在 InnoDB 中，**没有使用索引**，指的是从最左边的叶子节点开始向右扫描整个索引树。所以说，没有使用索引，并不是一个准确的描述。你可以用全表扫描或全索引扫描，表示他扫描了一个索引树，比如 ``select * from t where id > 0``。

而**使用了索引**，指的是类似 ``select * from t where id = 2`` 这样的 SQL 语句，使用了索引的快速搜索功能，并有效的减少了扫描行数。

下面我们看一个例子：

假设有一个表 ``t_people`` 存储了全中国所有的人，若要查询出年龄在 18岁到25岁的人，可以使用下面的 SQL 语句：

``` sql
select * from t_people where age between 18 and 25;
```

从这个 SQL 看，我们直观的知道如果不在 age 字段上建索引，则执行时间一定不乐观。但即使添加了索引，执行时间也没有直接的提升。我们分析一下这个 SQL 的执行流程：

