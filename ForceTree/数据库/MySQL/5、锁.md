### MySQL 锁机制

多线程或多进程会带来资源共享和抢占的问题。锁，则是计算机协调多个进城或线程并发访问某一资源的机制。

在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供徐多用户共享的资源。数据库锁机制，简单来说就是为了保证数据的一致性，而使各种共享资源在被并发访问时变得有序而设计的一种原则。

##### 1、锁的分类

对数据操作简单的类型分类：

1. 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响；
2. 写锁（拍他锁）：当前写操作没有完成前，它会阻塞其他写锁和读锁；

对数据操作的颗粒度分类：

为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据，会得到最大的并发度，但是管理锁是很小好资源的事情，它涉及到获取、检查、锁释放等操作，因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了『锁粒度（Lock Granularity）』的概念。

1. 表级锁：开销小，加锁快，不会出现死锁；但锁的颗粒度很大，发生锁冲突的概率最高，并发度最低（MyISAM和Memory存储引擎采用的是表级锁）；
2. 行级锁：开销大，加锁慢，会出现死锁；所得颗粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB存储引擎支持表级锁和行级锁，但默认情况下采用行级锁）；
3. 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁的颗粒度介于表锁和行锁质检，并发度一般。

适用：从锁的角度来说，表级锁更适合以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁更适合有大量按索引条件并发更新少量不同数据，同事又有并发查询的应用，如一些在线事务处理（OLTP）系统。

下表展示了一些数据引擎和支持的锁：

|        | 行锁 | 表锁 | 页锁 |
| ------ | ---- | ---- | ---- |
| MyISAM |      | ✓    |      |
| NDB    |      | ✓    | ✓    |
| InnoDB | ✓    | ✓    |      |
| Memory |      | ✓    |      |

##### 2、MyISAM 表锁

MyISAM的表锁有两种模式：

1. 表共享读锁（Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的谢请求；
2. 表独占写锁（Table Write Lock）：会阻塞其他用户对同一表的读和写操作；

MyISAM表的读和写操作之间，以及写和写操作之间是串行的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，指导锁被释放。

默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的线程获取锁请求，然后再给读锁队列中等候的线程获取锁请求。

##### 3、InnoDB行锁

InnoDB实现了以下两种类型的行锁：

1. 共享锁（S）：允许一个事务读取一行，组织其他事务货的相同数据集的排他锁；
2. 排他锁（X）：允许多的排他锁的事务 更新数据，组织其他事务取得相同数据集的共享读锁和排他写锁；

为了允许行锁和表锁共存，实现多颗粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：

1. 意向共享锁（IS）：在某个事务打算给数据行加行共享锁前，必须取得该表的意向共享锁。
2. 意向排他锁（IX）：在某个事务打算给数据行加行排他锁前，必须取得该表的意向排他锁。

**索引失效会导致行锁变表锁**。比如 varchar查询时不写单引号的情况。

##### 4、加锁机制

乐观锁与悲观锁是两种并发控制的思想，可以用于解决丢失更新的问题。

乐观锁，会乐观地假定大概率不会发生更新冲突，**访问、处理数据过程中不加锁，只在更新数据时根据版本号或时间戳判断是否有冲突**（读不加锁，写判断版本），有则处理，无则提交事务。用数据库版本（Version）记录机制实现，这是乐观锁最常用的一种实现。

悲观锁，会悲观地假定大概率会发生更新中图，访问、处理数据前就加排他锁阻止更新，在整个数据处理过程中锁定数据，事务提交或回滚时才释放锁。另外与乐观锁对应的，悲观锁是有数据库自己实现的，要用的时候，我们调用数据库相关语句。

##### 5、锁模式

**1）记录锁 Record Locks**

单个行记录上的锁，对索引项加锁，锁定符合条件的行，其他事务不能修改和删除加锁的项。

``` mysql
SELECT * FROM tableName WHERE id = 1 FOR UPDATE;
```

例如上面这句SQL，他会在id为1的记录上加记录锁，以组织其他事务插入、更新、删除 id为1的行。在通过主键索引与唯一索引对数据行进行UPDATE操作时，也会对该行数据加记录锁：

```mysql
-- id列为主键列 或 唯一索引列
UPDATE tableName SET age = 50 WHERE id = 1;
```

**2）间隙锁 Gap Locks**

当时用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的**索引项**加锁。对于键值在条件范围内但并不存在的记录，叫做『间隙』。InnoDB也会对这个间隙加锁，这种锁机制就是间隙锁。

对索引项之间的『间隙』加锁，锁定记录的范围（对第一条记录前的间隙或最后一条记录后的间隙加锁），不包含索引项本身。其他事务不能再锁范围内插入数据，这样房子了别的事务新增幻影行。

间隙锁基于非唯一索引，它锁定一段范围的索引记录。间隙锁基于下面将会提到的 ``Next-Key Locking`` 算法，请务必牢记：**使用间隙锁 锁住的是一个区间，而不仅仅是这个区间的每一条数据**。

```mysql
SELECT * FROM tableName WHERE id BETWEEN 1 AND 10 FOR UPDATE;
```

即所有在 (1, 10) 区间内的记录行都会被锁住，所有id为 2、3、4、5、6、7、8、9 的数据行的插入、更新和删除都会被阻塞，但是1和10 两条记录行不会被锁住。

Gap Locks的目的是为了防止同一个事务两次读取，出现幻读的情况。

**3）临键锁 Next-Key Locks**

记录锁与间隙锁的组合，他封锁的范围，即包含索引记录，又包含索引区间。临键锁的目的，也是为了避免幻读，如果把事务的隔离级别降级为读已提交 Read-Committed，临键锁会失效。

Next-Key 可以理解为一种特殊的间隙锁，也可以理解为一种特殊的算法。通过临键锁，可以解决幻读的问题。每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。

InnoDB中的行级锁，是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。

对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

**4）For Update**

For Update 仅适用于InnoDB，且必须在事务块（Begin/Commit）中才能生效。在进行事务操作时，通过 For Update 语句，MySQL会对查询结果集中的每行数据，都添加排他锁，其他线程对该记录的更新和删除都会被阻塞。排他锁包含行锁和表锁。

InnoDB这种行锁实现特点意味着，只有通过索引条件检索数据，InnoDB才使用行级锁，否则使用表锁。假设有个表 Student，里面有id和name两个字段，id是主键，则有：

```mysql
-- 明确指定主键，且有该条记录，则采用行锁
SELECT * FROM student WHERE id = '3' FOR UPDATE;
SELECT * FROM student WHERE id = '3' and name = 'Lxmajs' FORT UPDATE;

-- 明确指定主键，而没有改条记录，无锁
SELECT * FROM student WHERE id = '-1' FOR UPDATE;

-- 不明确主键，表锁
SELECT * FROM student WHERE name <> 'Lxmajs' FOR UPDATE;

-- 主键不明确，表锁
SELECT * FROM student WHERE id <> '3' FOR UPDATE;
SELECT * FROM student WHERE id LIKE '3' FOR UPDATE;
```



##### 6、死锁

**1）死锁产生**

死锁，是指两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也有可能产生死锁。锁的行为和顺序与存储引擎相关，以相同的顺序执行语句，有的存储引擎会产生死锁，有的则不会。死锁有双重原因：真正的数据冲突 和 存储引擎的实现方式。

**2）检测死锁**

数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到自锁循环依赖，并立即返回一个错误。

**3）死锁恢复**

死锁发生以后，只有部分完成或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级锁排他锁的事务进行回滚。所以事务型应用程序在设计时，必须考虑如何处理死锁。多数情况下只需要重新执行因死锁回滚的事务即可。

**4）外部锁的死锁检测**

发生死锁后，InnoDB一般都可以自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB并不能完全自动检测到死锁，这需要通过设置锁等待超时参数 ``innodb_lock_wait_timeout`` 来解决。

**5）死锁影响性能**

死锁会影响性能，而不是产生严重错误。因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。有时候当死锁发生时，禁用死锁检测（使用 ``innodb_deadlock_detect`` 配置选项）可能会更有效，这时可以依赖 ``innodb_lock_wait_timeout`` 设置进行事务回滚。

**6）避免死锁**

MyISAM在自动加锁的情况下，总是一次获得SQL语句所需要的全部锁，所以MyISAM表并不会出现死锁。

InnoDB则不同：

1. 为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个行使用 `` SELECT ... FOR UPDATE `` 语句来获得必要的锁，及时这些行的更改语句是在之后才执行的；
2. 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应该先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁；
3. 如果事务需要修改或锁定多个表，则应该在每个事务中，以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，赢尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会；
4. 通过 `` SELECT ... LOCK IN SHARE MODE `` 获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁；
5. 改变事务隔离级别；

如果出现死锁，可以用  ``show engine innodb status;``  命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如发生死锁的SQL语句，事务已经获得锁，正在等待什么锁，以及被回滚的事务等。据此可以分析产生死锁产生的原因和改进措施。
