### MySQL 索引

##### 一、概念

索引是用于辅助查询获得数据的数据结构，其目的是提高查询效率。索引本身不会很大，但不可能全部存储在内存中，一般的索引文件会存储在磁盘中。

##### 二、基本语法

1、创建/索引

``` mysql
 CREATE [UNIQUE] INDEX indexName ON tablename( columns );
```

2、删除索引

``` mysql
DROP INDEX indexName ON tablename;
```

3、查看索引

``` mysql
SHOW INDEX FROM tablename \G; -- \G 可格式化信息
```

4、编辑索引

``` mysql
-- 添加主键索引
ALTER TABLE tablename ADD PRIMARY KEY ( column );

-- 添加唯一索引，索引列的值必须是唯一的，NULL除外
ALTER TABLE tablename ADD UNIQUE indexname ( columns );

-- 添加普通索引，索引值可以出现多次，用于查询
ALTER TABLE tablename ADD INDEX indexname ( columns );

-- 添加全文索引
ALTER TABLE tablename ADD FULLTEXT indexname ( columns );
```

##### 三、优缺点

**优点：**

​	· 提高数据检索效率，降低数据库I/O成本；

​	· 降低数据排序成本，降低CPU消耗；

**缺点：**

​	· 索引的数据结构也需要存储和维护，它可能保存了主键和索引字段，并指向实体表的记录，也需要占内存；

​	· 可能降低更新和插入表的速度。更新表时，MySQL不进要保存数据，还要保存索引文件每次添加的索引列字段，比如调整索引树；

##### 四、索引分类

数据结构上划分：B树、B+树、Hash索引、全文索引、R-Tree索引

物理存储上划分：聚集索引（聚簇索引）、非聚集索引（非聚簇索引或辅助索引）

逻辑上划分：主键索引、普通单列索引、复合/联合索引、唯一索引、空间索引

##### 五、索引结构

索引，是存储引擎层面实现的，而不是server层面，不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一个索引类型，他们的实现和行为也有差别。

**1、B-Tree 索引**

B-Tree是为磁盘等 外存储设备 设计的一种平衡查找树。

系统从磁盘读取数据到内存时，是以 **磁盘块（block）**为单位的位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。

InnoDB存储引擎中是以 **页（page）**为磁盘管理的最小单位。InnoDB默认每个页大小是16KB，可通过 `` innodb_page_size `` 将也得大小设置为 4KB、8KB、16KB。

``` mysql
-- MySQL中可通过如下命令查看页大小
SHOW VARIABLES LIKE 'innodb_page_size';
```

然而，一个block的存储空间往往小于page，因此InnoDB每次申请磁盘空间，都是若干地址连续磁盘块来达到页大小，InnoDB把磁盘数据读入磁盘时也是以页为单位。因此我们得知：**查询数据时如果一个页中的每条数据都能有助于定位数据的位置，将会减少磁盘I/O次数，提高查询效率。**

一颗m阶B-Tree有如下特性：

> 1. 每个节点最多m个孩子
> 2. 除了根节点和叶子节点外，其他每个节点至少有 Ceil(m/2) 个孩子
> 3. 若根节点不是叶子节点，则至少有2个孩子（废话）
> 4. 所有叶子节点都在同一层，且不包含其他关键字信息
> 5. 每个非终端节点包含n个关键字信息（P0、P1、P2 ... Pn， k1、k2 ... kn）
> 6. 关键字的个数 n 满足：Ceil(m/2) - 1 ≤ n ≤ m -1
> 7. Ki(i = 1, ...n) 为关键字，且关键字升序
> 8. Pi(i = 1, ...n) 为指针，P(i-1) 指向的子树的所有节点的关键字，都小于 ki 且 都大于 k(i - 1)

B-Tree 中的每个节点，根据实际情况可以包含大量的关键字信息和分支，如下图所示，是一个3阶B-Tree：

![img](https://pic3.zhimg.com/80/v2-bf07856ffbdfe61816d1ecdd4ec583a6_1440w.jpg)

每个节点占用一个盘块的磁盘空间，一个节点上有2个升序排序的关键字和3个指向子树根节点的指针，指针存储的是**子节点所在磁盘块的地址**。

两个关键词划分成3个范围域，对应3个指针指向的子树。

>  模拟查找关键字29的过程：
>
> 1. 根据根节点找到磁盘块1，读入内存；【磁盘I/O Round1】
> 2. 比较关键字29所在区间 (17, 35)，找到磁盘块1的指针P2；
> 3. 根据P2找到磁盘块3，读入内存；【磁盘I/O Round2】
> 4. 比较关键字所在区间 (26, 30)，找到磁盘块3的指针P2；
> 5. 根据P2找到磁盘块8，读入内存；【磁盘I/O Round3】
> 6. 在磁盘块8的关键字列表中找到关键字 29；

分析上面的过程，发现需要3次I/O操作，和3次内存查找操作。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。但由于内存中的关键字是一个有序的表结构，可以利用二分查找提高效率。而3次磁盘I/O是影响整个B-Tree查找效率的关键因素。



**2、B+Tree 索引**

InnoDB和MyISAM都使用B+Tree的数据结构，他相对于B-Tree，所有的数据都放在叶子姐点上，且把叶子姐点通过指针连接到一起，行程一条数据链表，以加快相邻数据的检索效率。

B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构的。

B-Tree的结构图中可以看到，每个节点中不仅包含数据的key，也包含data，而每一页的存储空间有限，如果data数据交大时将会导致每一页能存储的key很少，这会加大B-Tree的深度，进而增加磁盘I/O的次数，影响查询效率。

在B+Tree中，**所有的data，都是按照key大小顺序存放在同一层叶子节点上，而非叶子节点只存储key**，这样可以加大每个非叶子节点存储的key数量，降低B+Tree的高度。

> B+Tree 与 B-Tree 的几点不同
>
> 1. 非叶子结点只存储key；
> 2. 叶子节点存储key和data；
> 3. 叶子节点之间有一个链指针；

将上一个B-Tree进行优化有，假设每个磁盘块能存储4个key和指针信息，那么将得到下面的B+Tree：

![img](https://pic3.zhimg.com/80/v2-e213b1289dd51d5943d1c5305ab5b63e_1440w.jpg)

> **Tips：**通常情况下，B+Tree中有2个头指针，一个指向根节点，一个指向key最小的叶子节点，而所有的叶子节点之间是一种链式环形结构，因此B+Tree天然支持2种查找运算：1）主键的范围查找和分页查找；2）从根节点开始的随机查找；

我们可以做出以下推演：

假设 `` innodb_page_size `` 默认为16KB，主键类型为INT(4bytes) 或 BIGINT(8bytes)，指针类型一般也是4或8bytes，那么：一个page中大约存储 16KB/(8Bytes+8Bytes) = 1KB个key，也就是说一个深度为3的B+Tree，可以维护 **1KB^3 ≈ 10亿** 条记录。

但实际情况中每个节点可能不能填满，因此在数据库中，B+Tree的高度一般都在2~4蹭。MySQL的InnoDB存储引擎在设计时，将根节点常驻内存的，查找某一键值的行记录时，最多只需要1~3次磁盘I/O操作。

>  **B+Tree的特性**

1. B+Tree的高度决定磁盘I/O的次数，假设当前数据表的数据为N，每个磁盘block的数据项数量是m，则有 h = log(m+1)N，当数量N一定的情况下，m越大，h越小；而 m = 磁盘block大小 / 数据项大小，磁盘block的大小也就是一个数据页page的大小，是固定的，如果数据项站的空间越小，数据项的数量就越多，树的高度越低。这就是为什么每个数据项（即索引字段）要尽量小，比如INT类型占4bytes，BIGINT占8bytes。这也是为什么B+Tree要求把data放在叶子节点而不是内层节点。若放在内层节点，磁盘块的数据项会大幅度减少，导致树层变高。当数据项等于1时，B+Tree将退化成线性表。
2. 当B+Tree的data是复合数据结构时，比如（name, age, sez），B+Tree会按照从左到右的顺序来构建索引树，即索引的最左匹配原则。

**3、MyISAM主键索引和辅助索引**

MyISAM的索引文件和数据文件是分离的，分别存储在 .MYD 和 .MYI 文件中。**MyISAM索引结构的叶子节点的data域，存放的并不是实际的数据记录，而是数据记录的地址。**索引文件和数据文件分离，这样的索引称为『非聚簇索引』。MyISAM的主键索引和辅助索引区别不大，只是主键索引不能有重复的关键字。

![img](https://pic3.zhimg.com/80/v2-7281aac18de64960d3b062a8c483117a_1440w.jpg)

1. 在MyISAM中，索引存放在单独的文件中，叶子节点存放数据的物理地址偏移量，通过偏移量访问就是磁盘的随机访问。
2. 主键索引的键值不可能重复，辅助索引可能重复；
3. 通过索引查找数据的流程：先从索引文件中查找索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位具体数据。辅助索引同理。

**4、InnoDB主键索引和辅助索引的结构**

InnoDB索引结构的叶子节点的data域，存放的就是实际的数据（对于主键索引，此处会存放表中的所有数据记录，对于辅助索引则会引用主键，索引的时候通过主键查找到对应的data行），或者说，**InnoDB的数据文件本身就是主键索引文件**，这样的索引被称为『聚簇索引』，一个表只能有一个聚簇索引。

**主键索引**

InnoDB的索引和数据存放在同一个 .ibd 文件中，因此他的索引结构是在同一个树节点中同时存放索引和数据。如下图，student 数据表中有 id、stu_id、name数据项：

![img](https://pic2.zhimg.com/80/v2-7d335799db4209b7fe692bcbc991453d_1440w.jpg)

当开启 `` innodb_file_per_table `` 后，InnoDB的数据文件可以按表切分，切分后的表独立一个 .ibd 文件，否则统一把一个数据库的表存放在一个 .ibdata 文件中。该项默认不开启。

**辅助索引**

以上方的student表的name一列为例，构建辅助索引，他的索引结构和主键索引的结构有较大差别，底层的叶子节点有2行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。

![img](https://pic3.zhimg.com/80/v2-c3392c098bd23a1f4a2db4063a509bb2_1440w.jpg)

对name一列进行条件搜索，需要2个步骤：

1）在辅助索引上检索name，到达叶子节点并获得主键；2）在主键索引上检索id；

这就是所谓的**回表**。

>  InnoDB的索引结构有以下几个特点：

1. 数据文件本身就是索引文件；
2. 表数据文件本身就是B+Tree组织的一个索引结构文件；
3. 聚簇索引中的叶子节点包含了完整的数据记录；
4. InnoDB表必须要有主键，并且推荐使用整型自增主键，若未明确主键，InnoDB将自动生成一个隐含的字段作为主键，类型为整型的6bytes；

**5、Hash索引**

通过一定的Hash算法（如直接定址法、平方取中法、折叠法、除数取余法、随机数法等），讲数据库字段的数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；若发生Hash碰撞（两个不同关键字的Hash值相同），则在对应的Hash键下以链表的形式存储。

使用Hash索引时，需要对查询关键字执行相同的Hash算法，得到Hash值，之后到对应的Hash表中取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的存储引擎并不多，主要是Memory、NDB等。

**6、Full-Text全文索引**

全文索引是MyISAM的一种特殊索引类型，主要用于全文检索。在MySQL 5.6版本之后，InnoDB也支持了全文索引。

它用于替代效率较低的Like模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。

全文索引使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个bytes分割一次），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应B-Tree结构的节点存储的是分割后的词信息，以及它在分割前的索引字符串集合中的位置。

**7、空间索引**

空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型。
